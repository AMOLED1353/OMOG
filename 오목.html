;<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Ïò§Î™© Í≤åÏûÑ (Í≥†Í∏â Î†àÎ≤®)</title>
    <style>
        body {
            font-family: 'Malgun Gothic', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
        }
        h1 {
            color: #2c3e50;
        }
        #game-container {
            display: flex;
            align-items: flex-start;
            gap: 40px;
        }
        #game-board {
            border: 2px solid #333;
            background-color: #dcb35c;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        #controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 200px;
        }
        #status {
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 20px;
            height: 30px;
            color: #e74c3c;
        }
        #score-board {
            font-size: 1.4em;
            margin-top: 20px;
            width: 100%;
            text-align: center;
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .button-group {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        #restart-btn {
            margin-top: 15px;
            background-color: #2ecc71;
        }
        #restart-btn:hover {
            background-color: #27ae60;
        }
    </style>
</head>
<body>

    <h1>AI Ïò§Î™© Í≤åÏûÑ (Í≥†Í∏â Î†àÎ≤®)</h1>

    <div id="game-container">
        <canvas id="game-board" width="600" height="600"></canvas>
        <div id="controls">
            <div id="score-board">
                üèÜ Ïä§ÏΩîÏñ¥ üèÜ<br>
                <span id="player-score">ÌîåÎ†àÏù¥Ïñ¥: 0</span> | <span id="ai-score">AI: 0</span>
            </div>
            
            <div id="status">ÏÉâÏÉÅÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</div>

            <div class="button-group">
                <button id="black-btn">ÌùëÎèå (ÏÑ†Í≥µ)</button>
                <button id="white-btn">Î∞±Îèå (ÌõÑÍ≥µ)</button>
            </div>
            
            <button id="restart-btn" disabled>ÏÉà Í≤åÏûÑ ÏãúÏûë</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');

        // Í≤åÏûÑ ÏÑ§Ï†ï
        const BOARD_SIZE = 15;
        const CELL_SIZE = canvas.width / BOARD_SIZE;
        const PADDING = CELL_SIZE / 2;

        // Í≤åÏûÑ ÏÉÅÌÉú Î≥ÄÏàò
        let board = [];
        let currentPlayer;
        let playerColor;
        let aiColor;
        let gameOver = true;
        let score = { player: 0, ai: 0 };
        
        // DOM ÏöîÏÜå
        const statusEl = document.getElementById('status');
        const blackBtn = document.getElementById('black-btn');
        const whiteBtn = document.getElementById('white-btn');
        const restartBtn = document.getElementById('restart-btn');
        const playerScoreEl = document.getElementById('player-score');
        const aiScoreEl = document.getElementById('ai-score');

        // --- Ï¥àÍ∏∞Ìôî Î∞è Í∑∏Î¶¨Í∏∞ Ìï®Ïàò ---

        function initBoard() {
            board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0));
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#dcb35c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;

            for (let i = 0; i < BOARD_SIZE; i++) {
                // ÏàòÏßÅÏÑ†
                ctx.beginPath();
                ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
                ctx.lineTo(PADDING + i * CELL_SIZE, canvas.height - PADDING);
                ctx.stroke();
                // ÏàòÌèâÏÑ†
                ctx.beginPath();
                ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
                ctx.lineTo(canvas.width - PADDING, PADDING + i * CELL_SIZE);
                ctx.stroke();
            }

            // ÌôîÏ†ê Í∑∏Î¶¨Í∏∞
            const starPoints = [3, 7, 11];
            ctx.fillStyle = '#000';
            starPoints.forEach(x => {
                starPoints.forEach(y => {
                    ctx.beginPath();
                    ctx.arc(PADDING + x * CELL_SIZE, PADDING + y * CELL_SIZE, 5, 0, 2 * Math.PI);
                    ctx.fill();
                });
            });
        }

        function drawStone(x, y, color) {
            const stoneX = PADDING + x * CELL_SIZE;
            const stoneY = PADDING + y * CELL_SIZE;
            const radius = CELL_SIZE / 2 - 4;

            ctx.beginPath();
            ctx.arc(stoneX, stoneY, radius, 0, 2 * Math.PI);

            const gradient = ctx.createRadialGradient(stoneX - radius/3, stoneY - radius/3, radius/4, stoneX, stoneY, radius);
            if (color === 1) { // ÌùëÎèå
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(1, '#000');
            } else { // Î∞±Îèå
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ddd');
            }
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        function redrawAllStones() {
            for(let y = 0; y < BOARD_SIZE; y++) {
                for(let x = 0; x < BOARD_SIZE; x++) {
                    if(board[y][x] !== 0) {
                        drawStone(x, y, board[y][x]);
                    }
                }
            }
        }

        // --- Í≤åÏûÑ Î°úÏßÅ ---

        function startGame(chosenColor) {
            playerColor = chosenColor;
            aiColor = (chosenColor === 1) ? 2 : 1;
            
            initBoard();
            drawBoard();
            
            currentPlayer = 1; // ÌùëÎèåÏù¥ Ìï≠ÏÉÅ ÏÑ†Í≥µ
            gameOver = false;
            
            blackBtn.disabled = true;
            whiteBtn.disabled = true;
            restartBtn.disabled = false;
            
            updateStatus();

            if (currentPlayer === aiColor) {
                setTimeout(aiMove, 500);
            }
        }

        function placeStone(x, y) {
            if (gameOver || board[y][x] !== 0) return false;

            board[y][x] = currentPlayer;
            drawStone(x, y, currentPlayer);

            if (checkWin(x, y, currentPlayer)) {
                endGame(currentPlayer);
                return true;
            }
            
            if (board.flat().every(cell => cell !== 0)) {
                endGame(0); // Î¨¥ÏäπÎ∂Ä
                return true;
            }

            currentPlayer = (currentPlayer === 1) ? 2 : 1;
            updateStatus();

            return true;
        }

        function checkWin(x, y, color) {
            // Í∞ÄÎ°ú, ÏÑ∏Î°ú, ÎåÄÍ∞ÅÏÑ† 2Î∞©Ìñ• Ï≤¥ÌÅ¨
            const directions = [
                { x: 1, y: 0 },  // Í∞ÄÎ°ú
                { x: 0, y: 1 },  // ÏÑ∏Î°ú
                { x: 1, y: 1 },  // ÎåÄÍ∞ÅÏÑ† \
                { x: 1, y: -1 }  // ÎåÄÍ∞ÅÏÑ† /
            ];

            for (const dir of directions) {
                let count = 1;
                // Ï†ïÎ∞©Ìñ•
                for (let i = 1; i < 5; i++) {
                    const nx = x + i * dir.x;
                    const ny = y + i * dir.y;
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === color) {
                        count++;
                    } else {
                        break;
                    }
                }
                // Ïó≠Î∞©Ìñ•
                for (let i = 1; i < 5; i++) {
                    const nx = x - i * dir.x;
                    const ny = y - i * dir.y;
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === color) {
                        count++;
                    } else {
                        break;
                    }
                }
                if (count >= 5) return true;
            }
            return false;
        }
        
        function endGame(winner) {
            gameOver = true;
            let message = "";
            if(winner === 0) {
                 message = "Î¨¥ÏäπÎ∂ÄÏûÖÎãàÎã§!";
            } else if (winner === playerColor) {
                message = "ÌîåÎ†àÏù¥Ïñ¥ ÏäπÎ¶¨! üéâ";
                score.player++;
            } else {
                message = "AI ÏäπÎ¶¨! ü§ñ";
                score.ai++;
            }
            statusEl.textContent = message;
            updateScore();
        }

        function restartGame() {
            initBoard();
            drawBoard();
            
            gameOver = true;
            
            blackBtn.disabled = false;
            whiteBtn.disabled = false;
            restartBtn.disabled = true;
            statusEl.textContent = "ÏÉâÏÉÅÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî";
        }
        
        function updateStatus() {
            if (gameOver) return;
            if (currentPlayer === playerColor) {
                statusEl.textContent = "ÎãπÏã†Ïùò Ï∞®Î°ÄÏûÖÎãàÎã§.";
            } else {
                statusEl.textContent = "AIÍ∞Ä ÏÉùÍ∞Å Ï§ëÏûÖÎãàÎã§...";
            }
        }
        
        function updateScore() {
            playerScoreEl.textContent = `ÌîåÎ†àÏù¥Ïñ¥: ${score.player}`;
            aiScoreEl.textContent = `AI: ${score.ai}`;
        }

        // --- AI Î°úÏßÅ (ÌïµÏã¨) ---
        function aiMove() {
            if (gameOver) return;
            
            statusEl.textContent = "AIÍ∞Ä ÏÉùÍ∞Å Ï§ëÏûÖÎãàÎã§...";
            
            // AIÍ∞Ä ÏµúÏ†ÅÏùò ÏàòÎ•º Ï∞æÎèÑÎ°ù ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ÏùÑ Ï§å (Í≥ÑÏÇ∞Ïù¥ ÎÑàÎ¨¥ Îπ®ÎùºÎèÑ Ïù¥ÏÉÅÌïòÎØÄÎ°ú)
            setTimeout(() => {
                const bestMove = findBestMove();
                if (bestMove) {
                    placeStone(bestMove.x, bestMove.y);
                }
            }, 300);
        }

        function findBestMove() {
            let bestScore = -Infinity;
            let move = null;
            const emptyCells = [];

            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (board[y][x] === 0) {
                        emptyCells.push({x, y});
                    }
                }
            }
            
            // Ï§ëÏïôÏóê Ï≤´ ÏàòÎ•º ÎëêÎäî Í≤ΩÌñ• (Ï¥àÎ∞ò Ï†ÑÎûµ)
            if (board.flat().filter(c => c !== 0).length < 2) {
                const centerX = Math.floor(BOARD_SIZE / 2);
                const centerY = Math.floor(BOARD_SIZE / 2);
                if (board[centerY][centerX] === 0) return {x: centerX, y: centerY};
            }

            // Í∞Å Îπà Ïπ∏Ïóê ÎåÄÌïú Ï†êÏàò Í≥ÑÏÇ∞
            for (const cell of emptyCells) {
                const {x, y} = cell;
                
                // AIÍ∞Ä Ïù¥Í∏∞Í±∞ÎÇò, ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ïù¥Í∏∞Îäî ÏàòÎ•º Ï¶âÏãú Ï∞æÏùå
                board[y][x] = aiColor;
                if (checkWin(x, y, aiColor)) {
                    board[y][x] = 0;
                    return {x, y};
                }
                
                board[y][x] = playerColor;
                 if (checkWin(x, y, playerColor)) {
                    board[y][x] = 0;
                    // ÏÉÅÎåÄÎ∞©Ïùò ÏäπÎ¶¨ ÏßÄÏ†êÏùÄ ÏµúÏö∞ÏÑ†ÏàúÏúÑÎ°ú Í≥†Î†§
                     let immediateThreatScore = 1000000;
                     if (immediateThreatScore > bestScore) {
                        bestScore = immediateThreatScore;
                        move = { x, y };
                    }
                    continue; // Îã§Î•∏ ÌèâÍ∞Ä ÏóÜÏù¥ Îã§Ïùå Îπà Ïπ∏ÏúºÎ°ú ÎÑòÏñ¥Í∞ê
                }
                board[y][x] = 0; // ÏõêÏÉÅÎ≥µÍµ¨

                // Ìú¥Î¶¨Ïä§Ìã± Ï†êÏàò Í≥ÑÏÇ∞
                const score = calculateHeuristicScore(x, y);
                if (score > bestScore) {
                    bestScore = score;
                    move = { x, y };
                }
            }
            
            // ÎßåÏïΩ ÏäπÎ¶¨/Î∞©Ïñ¥Ìï† Í≥≥Ïù¥ ÏóÜÎã§Î©¥ ÏµúÍ≥†Ï†ê ÏûêÎ¶¨ Î∞òÌôò
            if (move) return move;
            
            // Îëò Í≥≥Ïù¥ ÏóÜÎã§Î©¥ (Ïù¥Î°†ÏÉÅ Î∞úÏÉùÌïòÍ∏∞ ÌûòÎì¶)
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
        }

        function calculateHeuristicScore(x, y) {
            // AIÏùò Í≥µÍ≤© Ï†êÏàòÏôÄ ÌîåÎ†àÏù¥Ïñ¥Ïùò ÏàòÎπÑ Ï†êÏàòÎ•º Ìï©ÏÇ∞
            let score = 0;
            board[y][x] = aiColor; // AIÍ∞Ä ÎëîÎã§Í≥† Í∞ÄÏ†ï
            score += evaluateBoardForColor(aiColor) * 1.1; // Í≥µÍ≤©Ïóê ÏïΩÍ∞ÑÏùò Í∞ÄÏ§ëÏπò
            board[y][x] = playerColor; // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÎëîÎã§Í≥† Í∞ÄÏ†ï
            score += evaluateBoardForColor(playerColor);
            board[y][x] = 0; // ÏõêÏÉÅÎ≥µÍµ¨
            return score;
        }

        function evaluateBoardForColor(color) {
            let score = 0;
            const patterns = {
                'OOOO_': 50000,  // Ïó¥Î¶∞ 4
                '_OOOO_': 50000,
                'XOOOO_': 400,
                '_OOOOX': 400,
                'OO_OO': 400,
                'O_OOO': 400,
                'OOO_O': 400,
                
                'OOO__': 720,    // Ïó¥Î¶∞ 3
                '__OOO': 720,
                '_OOO_': 720,
                
                'XOOO__': 50,
                '__OOOX': 50,
                'X_OOO_X': 50,
                
                'OO___': 15,     // Ïó¥Î¶∞ 2
                '___OO': 15,
                '__O_O_': 15,
                '_O_O__': 15,
                
                'XOO___': 5,
                '___OOX': 5
            };

            // Í∞ÄÎ°ú, ÏÑ∏Î°ú, ÎåÄÍ∞ÅÏÑ† Í≤ÄÏÇ¨
            const lines = getAllLines();
            lines.forEach(line => {
                const lineStr = line.map(c => c === 0 ? '_' : (c === color ? 'O' : 'X')).join('');
                for (const pattern in patterns) {
                    if (lineStr.includes(pattern)) {
                        score += patterns[pattern];
                    }
                }
            });
            return score;
        }

        function getAllLines() {
            const lines = [];
            // Í∞ÄÎ°ú
            for (let y = 0; y < BOARD_SIZE; y++) lines.push(board[y]);
            // ÏÑ∏Î°ú
            for (let x = 0; x < BOARD_SIZE; x++) lines.push(board.map(row => row[x]));
            // ÎåÄÍ∞ÅÏÑ†
            for (let i = 0; i < BOARD_SIZE * 2 - 1; i++) {
                const diag1 = [], diag2 = [];
                for (let j = 0; j <= i; j++) {
                    const x = j, y = i - j;
                    if (y < BOARD_SIZE && x < BOARD_SIZE) diag1.push(board[y][x]);
                    const y2 = BOARD_SIZE - 1 - y;
                    if (y2 >= 0 && x < BOARD_SIZE) diag2.push(board[y2][x]);
                }
                if (diag1.length >= 5) lines.push(diag1);
                if (diag2.length >= 5) lines.push(diag2);
            }
            return lines;
        }
        
        // --- Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ---

        canvas.addEventListener('click', (e) => {
            if (gameOver || currentPlayer !== playerColor) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const x = Math.round((mouseX - PADDING) / CELL_SIZE);
            const y = Math.round((mouseY - PADDING) / CELL_SIZE);

            if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
            
            if (placeStone(x, y)) {
                if (!gameOver) {
                    aiMove();
                }
            }
        });

        blackBtn.addEventListener('click', () => startGame(1));
        whiteBtn.addEventListener('click', () => startGame(2));
        restartBtn.addEventListener('click', restartGame);

        // --- Ï¥àÍ∏∞ Ïã§Ìñâ ---
        drawBoard();
        initBoard();

    </script>
</body>
</html>